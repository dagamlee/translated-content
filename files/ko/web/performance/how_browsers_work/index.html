---
title: '웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가'
slug: Web/Performance/How_browsers_work
translation_of: Web/Performance/How_browsers_work
original_slug: Web/Performance/브라우저는_어떻게_동작하는가
---
<p>Users want web experiences with content that is fast to load and smooth to interact with. Therefore, <span class="seoSummary">a developer should strive to achieve these two goals. </span></p>

<p><span class="seoSummary">To understand how to improve performance and perceived performance, it helps to understand how the browser works.</span></p>

<h2 id="개요">개요</h2>

<p>Fast sites provide better user experiences. Users want and expect web experiences with content that is fast to load and smooth to interact with.</p>

<p>Two major issues in web performance are understanding issues having to do with latency and issues having to do with the fact that for the most part, browsers are single threaded.</p>

<p>Latency is our main threat to overcome to ensure a fast load. To be fast to load, the developers’ goals include sending requested information as fast as possible, or at least seem super fast. Network latency is the time it takes to transmit bytes over-the-air to computers. Web performance is what we have to do to make the page load happen as quickly as possible.</p>

<p>For the most part, browsers are considered single threaded. For smooth interactions, the developer's goal is to ensure performant site interactions, from smooth scrolling to being responsive to touch. Render time is key, with ensuring the main thread can complete all the work we throw at it and still always be available to handle user interactions. Web performance can be improved by understanding the single-threaded nature of the browser and minimizing the main thread's responsibilities, where possible and appropriate, to ensure rendering is smooth and responses to interactions are immediate.</p>

<h2 id="여정">여정</h2>

<p><em>Navigation</em> is the first step in loading a web page. It occurs whenever a user requests a page by entering a URL into the address bar, clicking a link, submitting a form, as well as other actions.</p>

<p>One of the goals of web performance is to minimize the amount of time a navigation takes to complete. In ideal conditions, this usually doesn't take too long, but latency and bandwidth are foes which can cause delays.</p>

<h3 id="DNS_Lookup">DNS Lookup</h3>

<p>The first step of navigating to a web page is finding where the assets for that page are located. If you navigate to <code>https://example.com</code>, the HTML page is located on the server with IP address of <code>93.184.216.34</code>. If you’ve never visited this site, a DNS lookup must happen.</p>

<p>Your browser requests a DNS lookup, which is eventually fielded by a name server, which in turn responds with an IP address. After this initial request, the IP will likely be cached for a time, which speeds up subsequent requests by retrieving the IP address from the cache instead of contacting a name server again.</p>

<p>DNS lookups usually only need to be done once per hostname for a page load. However, DNS lookups must be done for each unique hostname the requested page references. If your fonts, images, scripts, ads, and metrics all have different hostnames, a DNS lookup will have to be made for each one.</p>

<p><img alt="Mobile requests go first to the cell tower, then to a central phone company computer before being sent to the internet" src="https://mdn.mozillademos.org/files/16743/latency.jpg" style="height: 281px; width: 792px;"></p>

<p>This can be problematic for performance, particularly on mobile networks. When a user is on a mobile network, each DNS lookup has to go from the phone to the cell tower to reach an authoritative DNS server. The distance between a phone, a cell tower, and the name server can add significant latency.</p>

<h3 id="TCP_Handshake">TCP Handshake</h3>

<p>Once the IP address is known, the browser sets up a connection to the server via a {{glossary('TCP handshake','TCP three-way handshake')}}. This mechanism is designed so that two entities attempting to communicate—in this case the browser and web server—can negotiate the parameters of the network TCP socket connection before transmitting data, often over {{glossary('HTTPS')}}.</p>

<p>TCP's three way handshaking technique is often referred to as "SYN-SYN-ACK"—or more accurately SYN, SYN-ACK, ACK—because there are three messages transmitted by TCP to negotiate and start a TCP session between two computers. Yes, this means three more messages back and forth between each server, and the request has yet to be made.</p>

<h3 id="TLS_Negotiation">TLS Negotiation</h3>

<p>For secure connections established over HTTPS, another "handshake" is required. This handshake, or rather the {{glossary('TLS')}} negotiation, determines which cipher will be used to encrypt the communication, verifies the server, and establishes that a secure connection is in place before beginning the actual transfer of data. This requires three more round trips to the server before the request for content is actually sent.</p>

<p><img alt="The DNS lookup, the TCP handshake, and 5 steps of the TLS handshake including clienthello, serverhello and certificate, clientkey and finished for both server and client." src="https://mdn.mozillademos.org/files/16746/ssl.jpg" style="height: 412px; width: 729px;"></p>

<p>While making the connection secure adds time to the page load, a secure connection is worth the latency expense, as the data transmitted between the browser and the web server cannot be decrypted by a third party.</p>

<p>After the 8 round trips, the browser is finally able to make the request.</p>

<h2 id="응답">응답</h2>

<p>Once we have an established connection to a web server, the browser sends an initial <a href="/en-US/docs/Web/HTTP/Methods">HTTP <code>GET</code> request</a> on behalf of the user, which for websites is most often an HTML file. Once the server receives the request, it will reply with relevant response headers and the contents of the HTML.</p>

<pre class="brush: html">&lt;!doctype HTML&gt;
&lt;html&gt;
 &lt;head&gt;
  &lt;meta charset="UTF-8"/&gt;
  &lt;title&gt;My simple page&lt;/title&gt;
  &lt;link rel="stylesheet" src="styles.css"/&gt;
  &lt;script src="myscript.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1 class="heading"&gt;My Page&lt;/h1&gt;
  &lt;p&gt;A paragraph with a &lt;a href="https://example.com/about"&gt;link&lt;/a&gt;&lt;/p&gt;
  &lt;div&gt;
    &lt;img src="myimage.jpg" alt="image description"/&gt;
  &lt;/div&gt;
  &lt;script src="anotherscript.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>

<p>This response for this initial request contains the first byte of data received. {{glossary('Time to First Byte')}} (TTFB) is the time between when the user made the request—say by clicking on a link—and the receipt of this first packet of HTML. The first chunk of content is usually 14kb of data.</p>

<p>In our example above, the request is definitely less than 14Kb, but the linked resources aren't requested until the browser encounters the links during parsing, described below.</p>

<h3 id="TCP_Slow_Start_14kb_rule">TCP Slow Start / 14kb rule</h3>

<p>The first response packet will be 14Kb. This is part of {{glossary('TCP slow start')}}, an algorithm which balances the speed of a network connection. Slow start gradually increases the amount of data transmitted until the network's maximum bandwidth can be determined.</p>

<p>In {{glossary('TCP slow start')}}, after receipt of the initial packet, the server doubles the size of the next packet to around 28Kb. Subsequent packets increase in size until a predetermined threshold is reached, or congestion is experienced.</p>

<p><img alt="TCP slow start" src="https://mdn.mozillademos.org/files/16754/congestioncontrol.jpg" style="height: 412px; width: 729px;"></p>

<p>If you’ve ever heard of the 14Kb rule for initial page load, TCP slow start is the reason why the initial response is 14Kb, and why web performance optimization calls for focusing optimizations with this initial 14Kb response in mind. TCP slow start gradually builds up transmission speeds appropriate for the network's capabilities to avoid congestion.</p>

<h3 id="Congestion_control">Congestion control</h3>

<p><span style="font-weight: 400;">As the server sends data in TCP packets, the user's client confirms delivery by returning acknowledgements, or ACKs. The connection has a limited capacity depending on hardware and network conditions. If the server sends too many packets too quickly, they will be dropped. Meaning, there will be no acknowledgement. The server registers this as missing ACKs. Congestion control algorithms use this flow of sent packets and ACKs to determine a send rate.</span></p>

<h2 id="파싱">파싱</h2>

<p>브라우저가 첫 번째 데이터 묶음을 수신하면 수신된 정보를 파싱 할 수 있습니다. {{glossary('예측 파싱', '파싱')}}은 브라우저가 네트워크를 통해 수신한 데이터를 {{glossary('DOM')}} 과  {{glossary('CSSOM')}}으로 변환하기 위해 취하는 단계이며, 렌더러에 의해 화면에 페이지를 입힐 때 사용됩니다. </p>

<p>DOM은 브라우저에 대한 마크업의 내부 표현입니다. DOM도 노출되어 있으며, JavaScript의 다양한 API를 통해 조작할 수 있습니다.</p>

<p>요청 페이지의 HTML이 초기 14KB 패킷보다 크더라도, 브라우저는 가지고 있는 데이터를 기반으로 자기가 얻은 것을 파싱하고 렌더링하기 시작합니다. 때문에 웹 성능 최적화를 위해 브라우저가 페이지 렌더링을 시작하는 데 필요한 모든 것 또는 적어도 페이지의 템플릿, 즉 첫 번째 렌더에 필요한 CSS와 HTML을 처음 14 킬로바이트에 포함하는 것이 중요한 것입니다. 무엇보다도, HTML, CSS, JavaScript가 가장 먼저 파싱 되어야 합니다.</p>

<h3 id="Building_the_DOM_tree">DOM 트리 구축하기</h3>

<p>여기서는 <a href="/en-US/docs/Web/Performance/Critical_rendering_path">중요한 렌더링 경로</a>의 다섯 가지 단계를 설명하겠습니다.</p>

<p>첫 번째 단계는 HTML 마크업을 처리하고 DOM 트리를 구축하는 것입니다. HTML 파싱은 <a href="/en-US/docs/Web/API/DOMTokenList">토큰화</a>와 트리 구성을 포함한다. HTML 토큰에는 시작 및 종료 태그와 속성 이름 및 값이 포함됩니다. 문서가 잘 구성된 경우, 문서를 파싱하는 것이 쉽고 빠릅니다. 파서는 토큰화된 입력사항을 문서에 파싱하여 문서 트리를 구성합니다.</p>

<p>DOM 트리는 문서의 내용을 설명합니다. <code><a href="/en-US/docs/Web/HTML/Element/html">&lt;html&gt;</a></code>요소는 문서 트리의 첫 번째 태그 및 루트 노드입니다. 트리는 서로 다른 태그 간의 관계와 계층을 반영합니다. 다른 태그 내에 중첩된 태그는 하위 노드입니다. DOM 노드 수가 많을수록 DOM 트리를 구성하는 데 시간이 오래 걸립니다.</p>

<p><img alt="The DOM tree for our sample code, showing all the nodes, including text nodes." src="https://mdn.mozillademos.org/files/16759/DOM.gif" style="height: 689px; width: 754px;"></p>

<p>파서가 이미지와 같은 차단되지 않는 리소스를 찾으면 브라우저는 해당 리소스를 요청하고 파싱을 계속합니다. CSS 파일이 발견되면 파싱을 계속할 수 있지만, <code>&lt;script&gt;</code> 태그 (특히 <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/async_function">비동기</a></code> 또는 <code>지연 속성이 없는</code> 태그)는 렌더링을 차단하고 HTML의 파싱을 잠시 중단합니다. 브라우저의 프리로드 스캐너는 이 프로세스를 빠르게 하지만 과도한 스크립트는 여전히 프로세스를 정체시키는 결정적 요인입니다.</p> 

<h3 id="Preload_scanner">프리로드 스캐너</h3>

<p>브라우저가 DOM 트리를 빌드하는 동안 이 프로세스는 기본 스레드를 차지합니다. 이 경우 <em>프리로드 스캐너</em>는 사용 가능한 콘텐츠를 파싱하고 CSS, 자바스크립트, 웹 폰트와 같은 우선 순위가 높은 리소스를 요청합니다. 프리로드 스캐너 덕분에 파서가 외부 리소스에 대한 참조를 찾아서 요청할 때까지 기다릴 필요가 없습니다. 메인 HTML 파서가 요청된 자료(asset)에 도달할 때까지 백그라운드에서 리소스를 검색하여 이미 실행 중이거나 다운로드되었을 수 있습니다. 프리로드 스캐너가 최적화를 통해 정체되는 경우를 줄일 수 있습니다.</p>

<pre class="brush:html">&lt;link rel="stylesheet" src="styles.css"/&gt;
&lt;script src="myscript.js" <strong>async</strong>&gt;&lt;/script&gt;
&lt;img src="myimage.jpg" alt="image description"/&gt;
&lt;script src="anotherscript.js" <strong>async</strong>&gt;&lt;/script&gt;
</pre>

<p>위의 예에서 메인 스레드가 HTML과 CSS를 파싱하는 동안 프리로드 스캐너는 스크립트와 이미지를 찾고 다운로드도 시작합니다. 스크립트가 프로세스를 차단하지 않도록 하려면 <code>비동기</code> 속성을 추가하거나, JavaScript 파싱 및 실행 순서가 중요하지 않은 경우 <code>지연(defer)</code> 속성을 추가하십시오.</p>

<p>CSS를 가져오기 위해 기다리는 것은 HTML 파싱이나 다운로드를 차단하지 않지만, JavaScript는 차단합니다. 왜냐면 Javascript는 요소(elements)에 대한 CSS 속성의 영향을 쿼리하기 위해 종종 사용되기 때문입니다.</p>

<h3 id="Building_the_CSSOM">CSSOM 구축하기</h3>

<p>렌더링 경로의 두 번째 단계는 CSS를 처리하고 CSSOM 트리를 구축하는 것입니다. CSS 객체 모델은 DOM과 유사합니다. DOM과 CSSOM은 모두 트리입니다. 이들은 독립적인 데이터 구조입니다. 브라우저는 CSS 규칙을 이해하고 작업할 수 있는 스타일의 맵으로 변환됩니다. 브라우저는 CSS의 각 규칙 집합을 통해 CSS 선택기를 기반으로 부모, 자식, 형제 관계를 갖는 노드 트리를 만듭니다.</p>

<p>HTML과 마찬가지로 브라우저는 수신된 CSS 규칙을 사용할 수 있는 것으로 변환되어야 합니다. 따라서 CSS에 맞게 HTML-to-object 프로세스를 반복합니다.</p>

<p>CSSOM 트리는 사용자 에이전트 스타일 시트의 스타일을 포함합니다. 브라우저는 노드에 적용할 수 있는 가장 일반적인 규칙으로 시작하여 보다 구체적인 규칙을 적용하여 계산된 스타일을 재귀적으로 세분화합니다. 즉, 속성 값을 계단식으로 배열합니다.</p>

<p>CSSOM을 구축하는 것은 너무 빠르고, 현재의 개발 도구로는 개성 있는 모습으로 표현되지 않습니다. 오히려 개발자 도구의 "스타일 재계산(Recalculate Style)"은 CSS를 파싱하고, CSSOM 트리를 구성하고, 계산된 스타일을 재귀적으로 계산하는 데 걸리는 총 시간을 보여줍니다. 웹 성능 최적화 측면에서, CSSOM을 만드는 데 걸리는 총 시간이 일반적으로 하나의 DNS 룩업에 걸리는 시간보다 짧기 때문에 더 쉽게 결실을 얻을 수 있습니다.</p>

<h3 id="Other_Processes">그밖의 프로세스</h3>

<h4 id="JavaScript_Compilation">JavaScript 컴파일</h4>

<p>CSS가 구문 분석되고 CSSOM이 생성되는 동안 JavaScript파일을 포함한 다른 자료들이 다운로드됩니다. JavaScript는 해석되고, 컴파일되고, 파싱되고, 실행됩니다. 스크립트는 {{glossary('추상 구문 트리 (Abstract Syntax Tree)')}}로 파싱됩니다. 일부 브라우저 엔진은 추상 구문 트리를 가져와서 인터프리터에 전달하여 메인 스레드에서 실행되는 바이트 코드를 출력합니다. 이를 JavaScript 컴파일이라고 합니다.</p>

<h4 id="Building_the_Accessibility_Tree">접근성 트리 구축</h4>

<p>브라우저는 또한 <a href="/en-US/docs/Learn/Accessibility">접근성</a> 트리를 구축하는데, 보조 장치가 콘텐츠를 해석하고 해석하는 데 접근성 트리를 사용합니다. 접근성 객체 모델(AOM)은 DOM의 시맨틱 버전과 유사합니다. DOM이 업데이트되면 브라우저는 내게 필요한 옵션 트리를 업데이트합니다. 접근성 트리는 보조 기술 자체로는 수정할 수 없습니다.</p>

<p>AOM이 구축될 때까지 <a href="/en-US/docs/Web/Accessibility/ARIA/ARIA_Screen_Reader_Implementors_Guide">화면 판독기</a>가 콘텐츠에 액세스할 수 없습니다.</p>

<h2 id="렌더">렌더</h2>

<p>렌더링 단계에는 스타일, 레이아웃, 페인트가 포함되며, 경우에 따라서는 컴포지팅이 포함됩니다. 파싱단계에서 생성된 CSSOM과 DOM 트리는 렌더 트리로 결합되어 모든 가시적인 요소의 레이아웃을 계산하는데 사용되며 화면에 그려집니다. 어떤 경우에는 콘텐츠를 자체 레이어로 승격하고 컴포지트할 수 있으며 CPU 대신 GPU에 화면 일부를 도색하여 메인 스레드를 개방함으로써 성능을 향상시킵니다.</p>

<h3 id="Style">Style</h3>

<p>The third step in the critical rendering path is combining the DOM and CSSOM into a render tree.The computed style tree, or render tree, construction starts with the root of the DOM tree, traversing each visible node.</p>

<p>Tags that aren't going to be displayed, like the <code><a href="/en-US/docs/Web/HTML/Element/head">&lt;head&gt;</a></code> and its children and any nodes with <code>display: none</code>, such as the <code>script { display: none; }</code> you will find in user agent stylesheets, are not included in the render tree as they will not appear in the rendered output. Nodes with <code>visibility: hidden</code> applied are included in the render tree, as they do take up space. As we have not given any directives to override the user agent default, the <code>script</code> node in our code example above will not be included in the render tree.</p>

<p>Each visible node has its CSSOM rules applied to it. The render tree holds all the visible nodes with content and computed styles -- matching up all the relevant styles to every visible node in the DOM tree, and determining, based on the <a href="/en-US/docs/Web/CSS/Cascade">CSS cascade</a>, what the computed styles are for each node.</p>

<h3 id="Layout">Layout</h3>

<p>The fourth step in the critical rending path is running layout on the render tree to compute the geometry of each node. <em>Layout</em> is the process by which the width, height, and location of all the nodes in the render tree are determined, plus the determination of the size and position of each object on the page. <em>Reflow</em> is any subsequent size and position determination of any part of the page or the entire document.</p>

<p>Once the render tree is built, layout commences. The render tree identified which nodes are displayed (even if invisible) along with their computed styles, but not the dimensions or location of each node. To determine the exact size and location of each object, the browser starts at the root of the render tree and traverses it.</p>

<p>On the web page, most everything is a box. Different devices and different desktop preferences mean an unlimited number of differing viewport sizes. In this phase, taking the viewport size into consideration, the browser determines what the dimensions of all the different boxes are going to be on the screen. Taking the size of the viewport as its base, layout generally starts with the body, laying out the dimensions of all the body’s descendants, with each element's box model properties, providing placeholder space for replaced elements it doesn’t know the dimensions of, such as our image.</p>

<p>The first time the size and position of nodes are determined is called <em>layout</em>. Subsequent recalculations of node size and locations are called <em>reflows</em>.  In our example, suppose the initial layout occurs before the image is returned. Since we didn't declare the size of our image, there will be a reflow once the image size is known.</p>

<h3 id="Paint">Paint</h3>

<p>The last step in the critical rendering path is painting the individual nodes to the screen, the first occurence of which is called the <a href="/en-US/docs/Glossary/first_meaningful_paint">first meaningful paint</a>. In the painting or rasterization phase, the browser converts each box calculated in the layout phase to actual pixels on the screen. Painting involves drawing every visual part of an element to the screen, including text, colors, borders, shadows, and replaced elements like buttons and images. The browser needs to do this super quickly.</p>

<p>To ensure smooth scrolling and animation, everything occupying the main thread, including calculating styles, along with reflow and paint, must take the browser less than 16.67ms to accomplish. At 2048 X 1536, the iPad has over 3,145,000 pixels to be painted to the screen. That is a lot of pixels that have to be painted very quickly. To ensure repainting can be done even faster than the initial paint, the drawing to the screen is generally broken down into several layers. If this occurs, then compositing is necessary.</p>

<p>Painting can break the elements in the layout tree into layers. Promoting content into layers on the GPU (instead of the main thread on the CPU) improves paint and repaint performance. There are specific properties and elements that instantiate a layer, including <code><a href="/en-US/docs/Web/HTML/Element/video">&lt;video&gt;</a></code> and <code><a href="/en-US/docs/Web/HTML/Element/canvas">&lt;canvas&gt;</a></code>, and any element which has the CSS properties of <a href="/en-US/docs/Web/CSS/opacity"><code>opacity</code></a>, a 3D <code><a href="/en-US/docs/Web/CSS/transform">transform</a></code>, <code><a href="/en-US/docs/Web/CSS/will-change">will-change</a></code>, and a few others. These nodes will be painted onto their own layer, along with their descendants, unless a descendant necessitates its own layer for one (or more) of the above reasons.</p>

<p>Layers do improve performance, but are expensive when it comes to memory management, so should not be overused as part of web performance optimization strategies.</p>

<h3 id="Compositing">Compositing</h3>

<p>When sections of the document are drawn in different layers, overlapping each other, compositing is necessary to ensure they are drawn to the screen in the right order and the content is rendered correctly.</p>

<p>As the page continues to load assets, reflows can happen (recall our example image that arrived late).  A reflow sparks a repaint and a re-composite. Had we defined the size of our image, no reflow would have been necessary, and only the layer that needed to be repainted would be repainted, and composited if necessary. But we didn't include the image size! When the image is obtained from the server, the rendering process goes back to the layout steps and restarts from there.</p>

<h2 id="상호운용성">상호운용성</h2>

<p>Once the main thread is done painting the page, you would think we would be "all set." That isn't necessarily the case. If the load includes JavaScript, that was correctly deferred, and only executed after the <code><a href="/en-US/docs/Web/API/GlobalEventHandlers/onload">onload</a></code> event fires, the main thread might be busy, and not available for scrolling, touch, and other interactions.</p>

<p>{{glossary('Time to Interactive')}} (TTI) is the measurement of how long it took from that first request which led to the DNS lookup and SSL connection to when the page is interactive -- interactive being the point in time after the {{glossary('First Contentful Paint')}} when the page responds to user interactions within 50ms. If the main thread is occupied parsing, compiling, and executing JavaScript, it is not available and therefore not able to responsd to user interactions in a timely (less than 50ms) fashion.</p>

<p>In our example, maybe the image loaded quickly, but perhaps the <code>anotherscript.js</code> file was 2MB and our user's network connection was slow.  In this case the user would see the page super quickly, but wouldn't be able to scroll without jank until the script was downloaded, parsed and executed. That is not a good user experience. Avoid occupying the main thread, as demonstrated in this WebPageTest example:</p>

<p><img alt="The main thread is occupied by the downloading, parsing and execution of a  javascript file - over a fast connection" src="https://mdn.mozillademos.org/files/16760/visa_network.png" style="height: 699px; width: 1200px;"></p>

<p>In this example, the DOM content load process took over 1.5 seconds, and the main thread was fully occupied that entire time, unresponsive to click events or screen taps.</p>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li><a href="/en-US/docs/Web/Performance">Web Performance</a></li>
</ul>
